import type { VM } from '@stackblitz/sdk';

interface GeneratedFile {
  path: string;
  content: string;
}

export interface ReactProject {
  files: GeneratedFile[];
  dependencies: Record<string, string>;
}

export interface StackBlitzFiles {
  [path: string]: string;
}

/**
 * Prepares files for StackBlitz with Next.js App Router structure
 * Includes all necessary config files for Next.js
 */
export function prepareStackBlitzFiles(project: ReactProject): StackBlitzFiles {
  const files: StackBlitzFiles = {};

  // Add all generated files from AI
  project.files.forEach((f) => {
    files[f.path] = f.content;
  });

  // Add package.json with Next.js scripts
  files["package.json"] = JSON.stringify({
    name: "generated-nextjs-app",
    version: "0.1.0",
    private: true,
    scripts: {
      dev: "next dev",
      build: "next build",
      start: "next start",
      lint: "next lint"
    },
    dependencies: {
      ...project.dependencies,
      "next": "^14.0.0",
      "react": "^18.2.0",
      "react-dom": "^18.2.0",
      "lucide-react": "^0.294.0"
    },
    devDependencies: {
      "@types/node": "^20",
      "@types/react": "^18",
      "@types/react-dom": "^18",
      "typescript": "^5",
      "tailwindcss": "^3.3.0",
      "autoprefixer": "^10.4.16",
      "postcss": "^8.4.31"
    }
  }, null, 2);

  // Add next.config.js
  files["next.config.js"] = `/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'images.unsplash.com',
      },
      {
        protocol: 'https',
        hostname: 'via.placeholder.com',
      },
      {
        protocol: 'https',
        hostname: 'firebasestorage.googleapis.com',
      },
      {
        protocol: 'https',
        hostname: 'picsum.photos',
      },
    ],
  },
};
module.exports = nextConfig;`;

  // Add tailwind.config.js
  files["tailwind.config.js"] = `/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}`;

  // Add postcss.config.js
  files["postcss.config.js"] = `module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}`;

  // Add tsconfig.json
  files["tsconfig.json"] = JSON.stringify({
    compilerOptions: {
      lib: ["dom", "dom.iterable", "esnext"],
      allowJs: true,
      skipLibCheck: true,
      strict: true,
      noEmit: true,
      esModuleInterop: true,
      module: "esnext",
      moduleResolution: "bundler",
      resolveJsonModule: true,
      isolatedModules: true,
      jsx: "preserve",
      incremental: true,
      plugins: [{ name: "next" }],
      paths: {
        "@/*": ["./*"]
      }
    },
    include: ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
    exclude: ["node_modules"]
  }, null, 2);

  // Add globals.css (if not already generated by AI)
  if (!files["app/globals.css"]) {
    files["app/globals.css"] = `@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}`;
  }

  return files;
}

/**
 * Waits for the StackBlitz preview to be ready
 * Polls for preview URL availability
 * Note: This is optional - the embed will work even if this times out
 */
export async function waitForPreview(vm: VM, timeout: number = 10000): Promise<void> {
  const startTime = Date.now();
  const pollInterval = 500;

  return new Promise((resolve, reject) => {
    const checkPreview = async () => {
      try {
        const url = await vm.preview.getUrl();
        if (url) {
          resolve();
          return;
        }
      } catch (e) {
        // Preview not ready yet - this is normal during startup
      }

      if (Date.now() - startTime > timeout) {
        // Don't treat this as a critical error - just log it
        console.log('Preview URL detection timed out, but embed is running');
        resolve(); // Resolve instead of reject
        return;
      }

      setTimeout(checkPreview, pollInterval);
    };

    checkPreview();
  });
}
